import { validateGeneratedTypes } from "./validateGeneratedTypes";
it("should return no error if we use a deep external import", () => {
  const sourceTypes = {
    sourceText: `
    import { Hero } from "./hero-module.ts"

    export interface Citizen {
      hero: Hero
    };
  `,
    relativePath: "source.ts",
  };

  const zodSchemas = {
    sourceText: `// Generated by ts-to-zod
  import { z } from "zod";

  import { Hero } from "./hero-module.ts"

  const heroSchema = z.any();

  export const citizenSchema = z.object({
    hero: heroSchema
  });
  `,
    relativePath: "source.zod.ts",
  };

  const integrationTests = {
    sourceText: `// Generated by ts-to-zod
    import { z } from "zod";

    import * as spec from "./${sourceTypes.relativePath.slice(0, -3)}";
    import * as generated from "./${zodSchemas.relativePath.slice(0, -3)}";

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function expectType<T>(_: T) {
      /* noop */
    }

    export type CitizenInferredType = z.infer<typeof generated.citizenSchema>;

    expectType<CitizenInferredType>({} as spec.Citizen);
    expectType<spec.Citizen>({} as CitizenInferredType);
`,
    relativePath: "source.integration.ts",
  };

  interface File {
    sourceText: string;
    relativePath: string;
  }

  const extraFiles: File[] = [
    // {
    //   sourceText: `export class Hero {}`,
    //   relativePath: "hero-module.ts",
    // },
  ];

  const errors = validateGeneratedTypes({
    sourceTypes,
    zodSchemas,
    integrationTests,
    skipParseJSDoc: false,
    extraFiles,
  });

  expect(errors).toEqual([]);
});

// ðŸ¤¦
// Yep, this typo fixes the use case...

// So actually, the issue is different and only appears on my branch, which introduces _import handling_, when we reference imported types/interfaces (which are transformed to `z.instanceof`).
// It is the same issue as discussed in https://github.com/colinhacks/zod/issues/2203.

// I spent some more time digging, and it appears the issue has nothing to do with my rebase to the last version of `ts-to-zod`: only related to https://github.com/colinhacks/zod/issues/2203.

// Anyway, I would gladly use some brain juice to solve it ðŸ˜‰ and see how we can make sure the `validateGeneratedTypes` passes.

// ### Trying to reproduce https://github.com/colinhacks/zod/issues/2203 with `validateGeneratedTypes`

// I implemented the use case described in https://github.com/colinhacks/zod/issues/2203 in a new test (https://github.com/tvillaren/ts-to-zod/commit/68acbed400af647a1170fe423e68c9ca8137e2c9) and it passes validation with `validateGeneratedTypes`.
// But when looking at the actual inferred type via a `console.log` output of VFS, I see the same behavior as mention in  https://github.com/colinhacks/zod/issues/2203:

// ```ts
// type CitizenInferredType = {
//   heroAliases: (string[] | number[]) & (string[] | number[] | undefined);
// }
// ```

// You can try comparing both type in your IDE:

// ```ts
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// function expectType<T>(_: T) {
//   /* noop */
// }

// export type Citizen = {
//   heroAliases: string[] | number[];
// };

// export const citizenSchema = z.object({
//   heroAliases: z.union([z.string().array(), z.number().array()]),
// });

// export type CitizenInferredType = z.infer<typeof citizenSchema>;

// expectType<CitizenInferredType>({} as Citizen);
// expectType<Citizen>({} as CitizenInferredType);
// ```
// (I tried it in a VS Code with same version of TS & `zod` without error).

// ### Failing `validateGeneratedTypes` with imported types

// The validation error occurs on my branch. Here is one use case that fails.

// ```ts
// // eslint-disable-next-line @typescript-eslint/no-unused-vars
// function expectType<T>(_: T) {
//   /* noop */
// }

// export interface Citizen {
//   villain: ObjectId;
//   heroData: {
//     name: string;
//     hero: Number;
//   };
// }

// const numberSchema = z.instanceof(ObjectId);

// export const citizenSchema2 = z.object({
//   villain: numberSchema,
//   heroData: z.object({
//     name: z.string(),
//     hero: numberSchema,
//   }),
// });
// export type CitizenInferredType2 = z.infer<typeof citizenSchema2>;

// expectType<CitizenInferredType2>({} as Citizen2);
// expectType<Citizen2>({} as CitizenInferredType2);
// ```
