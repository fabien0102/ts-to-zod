import { ensureDir, writeFile } from "fs-extra";
import { join } from "path";
import temp from "temp";
import { generate } from "./generate";

describe("generate", () => {
  let tempOpen: string;

  beforeAll(async () => {
    temp.track();
    tempOpen = await temp.mkdir("ts-to-zod");
  });

  describe("simple case", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      export type Name = "superman" | "clark kent" | "kal-l";

      // Note that the Superman is declared after
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      export interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }

      const fly = () => console.log("I can fly!");
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const nameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const supermanSchema = z.object({
            name: nameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });

        export const badassSupermanSchema = supermanSchema.omit({ \\"underKryptonite\\": true });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type nameSchemaInferredType = z.infer<typeof generated.nameSchema>;

        export type supermanSchemaInferredType = z.infer<typeof generated.supermanSchema>;

        export type badassSupermanSchemaInferredType = z.infer<typeof generated.badassSupermanSchema>;

        expectType<spec.Name>({} as nameSchemaInferredType)
        expectType<nameSchemaInferredType>({} as spec.Name)
        expectType<spec.Superman>({} as supermanSchemaInferredType)
        expectType<supermanSchemaInferredType>({} as spec.Superman)
        expectType<spec.BadassSuperman>({} as badassSupermanSchemaInferredType)
        expectType<badassSupermanSchemaInferredType>({} as spec.BadassSuperman)
        "
      `);
    });
    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("with enums", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      export enum Superhero {
        Superman = "superman",
        ClarkKent = "clark-kent"
      };

      export type FavoriteSuperhero = {
        superhero: Superhero.Superman
      };
      `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "superhero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "superhero",
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Superhero } from \\"./superhero\\";

        export const superheroSchema = z.nativeEnum(Superhero);

        export const favoriteSuperheroSchema = z.object({
            superhero: z.literal(Superhero.Superman)
        });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type superheroSchemaInferredType = z.infer<typeof generated.superheroSchema>;

        export type favoriteSuperheroSchemaInferredType = z.infer<typeof generated.favoriteSuperheroSchema>;

        expectType<spec.Superhero>({} as superheroSchemaInferredType)
        expectType<superheroSchemaInferredType>({} as spec.Superhero)
        expectType<spec.FavoriteSuperhero>({} as favoriteSuperheroSchemaInferredType)
        expectType<favoriteSuperheroSchemaInferredType>({} as spec.FavoriteSuperhero)
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("with circular references", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      export interface Villain {
        name: string;
        powers: string[];
        friends: Villain[];
      }

      export interface EvilPlan {
        owner: Villain;
        description: string;
        details: EvilPlanDetails;
      }

      export interface EvilPlanDetails {
        parent: EvilPlan;
        steps: string[];
      }

      export interface IHaveUnknownDependency {
        dep: UnknwonDependency; // <- Missing dependency
      }
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "villain.ts",
          content: sourceText,
        },
        output: {
          relativePath: "villain",
        },
      });

      generateResult = await generate({
        inputPath: filesRef?.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Villain, EvilPlan, EvilPlanDetails } from \\"./villain\\";

        export const villainSchema: z.ZodSchema<Villain> = z.lazy(() => z.object({
            name: z.string(),
            powers: z.array(z.string()),
            friends: z.array(villainSchema)
        }));

        export const evilPlanSchema: z.ZodSchema<EvilPlan> = z.lazy(() => z.object({
            owner: villainSchema,
            description: z.string(),
            details: evilPlanDetailsSchema
        }));

        export const evilPlanDetailsSchema: z.ZodSchema<EvilPlanDetails> = z.lazy(() => z.object({
            parent: evilPlanSchema,
            steps: z.array(z.string())
        }));
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type villainSchemaInferredType = z.infer<typeof generated.villainSchema>;

        export type evilPlanSchemaInferredType = z.infer<typeof generated.evilPlanSchema>;

        export type evilPlanDetailsSchemaInferredType = z.infer<typeof generated.evilPlanDetailsSchema>;

        expectType<spec.Villain>({} as villainSchemaInferredType)
        expectType<villainSchemaInferredType>({} as spec.Villain)
        expectType<spec.EvilPlan>({} as evilPlanSchemaInferredType)
        expectType<evilPlanSchemaInferredType>({} as spec.EvilPlan)
        expectType<spec.EvilPlanDetails>({} as evilPlanDetailsSchemaInferredType)
        expectType<evilPlanDetailsSchemaInferredType>({} as spec.EvilPlanDetails)
        "
      `);
    });

    it("should have some errors", () => {
      expect(generateResult?.errors).toMatchInlineSnapshot(`
        Array [
          "Some schemas can't be generated due to direct or indirect missing dependencies:
        iHaveUnknownDependencySchema",
        ]
      `);
    });
  });

  describe("with options", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `export interface Superman {
      /**
       * Name of superman
       */
      name: string;
    }

    export interface Villain {
      name: string;
      didKillSuperman: true;
    }
    `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "villain.ts",
          content: sourceText,
        },
        output: {
          relativePath: "villain",
        },
      });

      generateResult = await generate({
        inputPath: filesRef?.input.path as string,
        nameFilter: (id) => id === "Superman",
        getSchemaName: (id) => id.toLowerCase(),
        keepComments: true,
      });
    });

    it("should generate superman schema", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const superman = z.object({
            /**
             * Name of superman
             */
            name: z.string()
        });
        "
      `);
    });
  });

  describe("inheritance and reference type search", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
    export type Name = "superman" | "clark kent" | "kal-l";
    export interface Superman {
      name: Name;
    }`;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "superman.ts",
          content: sourceText,
        },
        output: {
          relativePath: "superman",
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
        nameFilter: (id) => id === "Superman",
        getSchemaName: (id) => id.toLowerCase(),
        keepComments: true,
      });
    });

    it("should generate superman schema", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const name = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const superman = z.object({
            name: name
        });
        "
      `);
    });
  });

  describe("with jsdocTags filter", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      /**
       * @zod
       **/
      export type Name = "superman" | "clark kent" | "kal-l";

      /**
       * @nop
       */
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      /**
       * Only this interface should be generated
       *
       * @zod
       */
      export interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }
      `;
    it("should generate only types with @zod", async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
      });

      generateResult = await generate({
        inputPath: filesRef?.input.path as string,
        jsDocTagFilter: (tags) => tags.map((tag) => tag.name).includes("zod"),
      });

      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const nameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const supermanSchema = z.object({
            name: nameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });
        "
      `);
    });
  });

  describe("with non-exported types", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      export type Name = "superman" | "clark kent" | "kal-l";

      // Note that the Superman is declared after
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }
      `;
    it("should generate tests for exported schemas", async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "source.ts",
          content: sourceText,
        },
        output: {
          relativePath: "source.zod.ts",
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });

      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type nameSchemaInferredType = z.infer<typeof generated.nameSchema>;

        export type badassSupermanSchemaInferredType = z.infer<typeof generated.badassSupermanSchema>;

        expectType<spec.Name>({} as nameSchemaInferredType)
        expectType<nameSchemaInferredType>({} as spec.Name)
        expectType<spec.BadassSuperman>({} as badassSupermanSchemaInferredType)
        expectType<badassSupermanSchemaInferredType>({} as spec.BadassSuperman)
        "
      `);
    });
  });

  describe("with namespace", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
      export namespace Metropolis {
        export type Name = "superman" | "clark kent" | "kal-l";

        // Note that the Superman is declared after
        export type BadassSuperman = Omit<Superman, "underKryptonite">;

        export interface Superman {
          name: Name;
          age: number;
          underKryptonite?: boolean;
          /**
           * @format email
           **/
          email: string;
        }

        const fly = () => console.log("I can fly!");
      }
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const metropolisNameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const metropolisSupermanSchema = z.object({
            name: metropolisNameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });

        export const metropolisBadassSupermanSchema = metropolisSupermanSchema.omit({ \\"underKryptonite\\": true });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type metropolisNameSchemaInferredType = z.infer<typeof generated.metropolisNameSchema>;

        export type metropolisSupermanSchemaInferredType = z.infer<typeof generated.metropolisSupermanSchema>;

        export type metropolisBadassSupermanSchemaInferredType = z.infer<typeof generated.metropolisBadassSupermanSchema>;

        expectType<spec.MetropolisName>({} as metropolisNameSchemaInferredType)
        expectType<metropolisNameSchemaInferredType>({} as spec.MetropolisName)
        expectType<spec.MetropolisSuperman>({} as metropolisSupermanSchemaInferredType)
        expectType<metropolisSupermanSchemaInferredType>({} as spec.MetropolisSuperman)
        expectType<spec.MetropolisBadassSuperman>({} as metropolisBadassSupermanSchemaInferredType)
        expectType<metropolisBadassSupermanSchemaInferredType>({} as spec.MetropolisBadassSuperman)
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors).toEqual([]);
    });
  });

  describe("with @strict tag", () => {
    it("should generate strict keyword", async () => {
      const sourceText = `
      /**
       * @strict
       */
      export interface Superman {
        name: string;
        age: number;
      }

      export interface Villain {
        name: string;
        /**
         * @strict
         */
        nemesis: {
          name: string;
          ref: Superman
        };
      }
      `;

      const filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "source.ts",
          content: sourceText,
        },
        output: {
          relativePath: "source.zod.ts",
        },
      });

      const { getZodSchemasFile } = await generate({
        inputPath: filesRef.input.path as string,
      });

      expect(getZodSchemasFile("./source")).toMatchInlineSnapshot(`
      "// Generated by ts-to-zod
      import { z } from \\"zod\\";

      export const supermanSchema = z.object({
          name: z.string(),
          age: z.number()
      }).strict();

      export const villainSchema = z.object({
          name: z.string(),
          nemesis: z.object({
              name: z.string(),
              ref: supermanSchema
          }).strict()
      });
      "
      `);
    });
  });

  describe("importing named export types from another file", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import { HeadQuarters } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
        }
      `;
    const sourceTextUtils = `
        export type HeadQuarters = {
          name: string;
          location: string;
        };
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const headQuartersSchema = z.object({
            name: z.string(),
            location: z.string()
        });

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: headQuartersSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors).toEqual([]);
    });
  });

  describe("importing aggregated named export types from another file", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import { HeadQuarters } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
        }
      `;
    const sourceTextUtils = `
        type HeadQuarters = {
          name: string;
          location: string;
        };
        export { HeadQuarters };
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const headQuartersSchema = z.object({
            name: z.string(),
            location: z.string()
        });

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: headQuartersSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors).toEqual([]);
    });
  });

  describe("importing named aliased export types from another file", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import { HeadQuarters as HQs, Color} from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HQs;
          favoriteColor: Color;
        }
      `;
    const sourceTextUtils = `
        export type HeadQuarters = {
          name: string;
          location: string;
        };
        export type Color = 'black' | 'white';
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const hQsSchema = z.object({
            name: z.string(),
            location: z.string()
        });
        
        export const colorSchema = z.union([z.literal(\\"black\\"), z.literal(\\"white\\")]);

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: hQsSchema,
            favoriteColor: colorSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors).toEqual([]);
    });
  });

  describe("importing mixed export types from another file", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import HeadQuarters, { Vehicle, Color } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
          vehicle: Vehicle;
        }
      `;
    const sourceTextUtils = `
        type HeadQuarters = {
          name: string;
          location: string;
        };
        type Color = string;
        export type VehicleKind = 'car' | 'plane' | 'boat';
        export type Vehicle = {
          kind: VehicleKind
          color: string
          mileage: number;
        }
        
        export { Color };
        export default HeadQuarters;
      `;
    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        inputUtils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
      "// Generated by ts-to-zod
      import { z } from \\"zod\\";
      
      export const headQuartersSchema = z.object({
          name: z.string(),
          location: z.string()
      });
      
      export const colorSchema = z.string();
      
      export const vehicleKindSchema = z.union([z.literal(\\"car\\"), z.literal(\\"plane\\"), z.literal(\\"boat\\")]);
      
      export const vehicleSchema = z.object({
          kind: vehicleKindSchema,
          color: z.string(),
          mileage: z.number()
      });
      
      export const enemySchema = z.object({
          name: z.string(),
          inPrison: z.boolean(),
          headQuarters: headQuartersSchema,
          vehicle: vehicleSchema
      });
      "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors).toEqual([]);
    });
  });

  describe("Parse typeLiteral properties as we do with interface properties", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import { Sport } from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: Sport;
         }; 
    `;
    const sourceTextUtils = `
        type Sport = "football" | "basketball" | "baseball";
        export { Sport };
    `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "hero.ts",
          content: sourceText,
        },
        output: {
          relativePath: "hero",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const sportSchema = z.union([z.literal(\\"football\\"), z.literal(\\"basketball\\"), z.literal(\\"baseball\\")]);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: sportSchema
        });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(
        generateResult?.getIntegrationTestFile(
          filesRef?.input.path as string,
          filesRef?.output.path as string
        )
      ).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${filesRef?.input.path as string}\\";
        import * as generated from \\"${filesRef?.output.path as string}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }
        
        export type sportSchemaInferredType = z.infer<typeof generated.sportSchema>;
        
        expectType<spec.Sport>({} as sportSchemaInferredType)
        expectType<sportSchemaInferredType>({} as spec.Sport)
        "
        `);
    });
    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Importing default export type", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import FavoriteSport from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
         }; 
    `;
    const sourceTextUtils = `
        type Sport = "football" | "basketball" | "baseball";
        export default Sport;
    `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const favoriteSportSchema = z.union([z.literal(\\"football\\"), z.literal(\\"basketball\\"), z.literal(\\"baseball\\")]);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Importing default export enum", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import FavoriteSport from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
         }; 
    `;
    const sourceTextUtils = `
        enum Sport  {
          Football,
          Basketball,
        }
        export type Color = "red" | "blue";
        export default Sport;
    `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import FavoriteSport from \\"./utils\\";
        
        export const favoriteSportSchema = z.nativeEnum(FavoriteSport);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Deep nesting imported types", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import FavoriteSport from "./utils";
        import { Nationality } from "./utils/extra
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
             nationality: Nationality;
         }; 
    `;
    const sourceTextUtils = `
        import { Color } from "./color";
        export { Color }
        enum Sport  {
          Football,
          Basketball,
        }
        export default Sport;
    `;
    const sourceTextUtilsColor = `
        export type Color = "red" | "blue";
    `;
    const sourceTextUtilsExtra = `
      export enum Nationality {
        American,
        Canadian,
        Italian,
      }
    `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
        utilsColor: {
          relativePath: "colors/index.ts",
          content: sourceTextUtilsColor,
        },
        utilsExtra: {
          relativePath: "utils/extra.ts",
          content: sourceTextUtilsExtra,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import FavoriteSport from \\"./utils\\";
        import { Nationality } from \\"./utils/extra\\";
        
        export const favoriteSportSchema = z.nativeEnum(FavoriteSport);

        export const nationalitySchema = z.nativeEnum(Nationality);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema,
            nationality: nationalitySchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Imports with aliased namespace (import * as Namespaced from './colors')", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
       import * as UtilsColor from "./colors";
       import Sport from "./utils";
       type Enemy = {
            name: string;
            color: UtilsColor.Primary;
            sport: Sport;
       }; 
   `;
    const sourceTextUtils = `
       type Sport = {
          name: string;
       }
       export default Sport;
   `;
    const sourceTextUtilsColor = `
       export type Primary = "red" | "blue" | "yellow";
   `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
        utilsColor: {
          relativePath: "colors/index.ts",
          content: sourceTextUtilsColor,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
       "// Generated by ts-to-zod
       import { z } from \\"zod\\";
       
       export const utilsColorPrimarySchema = z.union([z.literal(\\"red\\"), z.literal(\\"blue\\"), z.literal(\\"yellow\\")]);

       export const sportSchema = z.object({
           name: z.string()
       });
       
       const enemySchema = z.object({
           name: z.string(),
           color: utilsColorPrimarySchema,
           sport: sportSchema
       });
       "
     `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Medium complexity aliased namespace imports", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
       import * as UtilsColor from "./colors";
       type Enemy = {
            name: string;
            color: UtilsColor.Primary;
       }; 
   `;
    const sourceTextUtilsColor = `
        export type red = "red";
        export type blue = "blue";
        export type yellow = "yellow";
        
        export type Primary = red | blue | yellow;
       
   `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utilsColor: {
          relativePath: "colors/index.ts",
          content: sourceTextUtilsColor,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
       "// Generated by ts-to-zod
       import { z } from \\"zod\\";
       
       export const utilsColorRedSchema = z.literal(\\"red\\");
       
       export const utilsColorBlueSchema = z.literal(\\"blue\\");
       
       export const utilsColorYellowSchema = z.literal(\\"yellow\\");
       
       export const utilsColorPrimarySchema = z.union([utilsColorRedSchema, utilsColorBlueSchema, utilsColorYellowSchema]);
       
       const enemySchema = z.object({
           name: z.string(),
           color: utilsColorPrimarySchema
       });
       "
     `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  describe("Cross Referencing imported types", () => {
    let filesRef: undefined | TestFileItems;
    let generateResult: undefined | Awaited<ReturnType<typeof generate>>;
    const sourceText = `
        import FavoriteSport from "./utils";
        import { Nationality } from "./utils/extra
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
             nationality: Nationality;
         }; 
    `;
    const sourceTextUtils = `
        import { Color } from "./colors";
        import { Nationality as Nations } from "./utils/extra";
        export { Color }
        enum SportTypes  {
          Football,
          Basketball,
        }
        type Sport = {
           nation: Nations
           color: Color
        }
        export default Sport;
    `;
    const sourceTextUtilsColor = `
        export type Color = "red" | "blue";
    `;
    const sourceTextUtilsExtra = `
      export enum Nationality {
        American,
        Canadian,
        Italian,
      }
    `;

    beforeAll(async () => {
      filesRef = await testFileGenerator(tempOpen, {
        input: {
          relativePath: "main.ts",
          content: sourceText,
        },
        output: {
          relativePath: "main",
        },
        utils: {
          relativePath: "utils.ts",
          content: sourceTextUtils,
        },
        utilsColor: {
          relativePath: "colors/index.ts",
          content: sourceTextUtilsColor,
        },
        utilsExtra: {
          relativePath: "utils/extra.ts",
          content: sourceTextUtilsExtra,
        },
      });

      generateResult = await generate({
        inputPath: filesRef.input.path as string,
      });
    });

    it("should generate the zod schemas", () => {
      expect(generateResult?.getZodSchemasFile(filesRef?.output.path as string))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Nationality } from \\"./utils/extra\\";
        
        export const colorSchema = z.union([z.literal(\\"red\\"), z.literal(\\"blue\\")]);

        export const nationsSchema = z.nativeEnum(Nationality);

        export const favoriteSportSchema = z.object({
            nation: nationsSchema,
            color: colorSchema
        });
        
        export const nationalitySchema = z.nativeEnum(Nationality);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema,
            nationality: nationalitySchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(generateResult?.errors.length).toBe(0);
    });
  });

  afterAll(async () => {
    await temp.cleanup();
  });
});

type TestFileItem = {
  /**
   * the name of the file including the relative path
   */
  relativePath: string;
  /**
   * the role identifies what type of file this is:
   * input: the typescript file used for generating the zod schemas
   * output: the zod schemas file
   * complementary: a file that is in the import chain of the input file
   */
  /**
   * the content of the file
   * in case of the output file the content is not provided
   */
  content?: string;
  /**
   * once created the file will be written to disk and this will be the path
   */
  path?: string;
};

type TestFileItems = {
  input: TestFileItem;
  output: TestFileItem;
} & Record<string, TestFileItem>;

/**
 * Populates a temporary directory with the files info provided
 * @param tempOpen
 * @param items
 */
async function testFileGenerator(tempOpen: string, items: TestFileItems) {
  const files: Array<[string, TestFileItem]> = await Promise.all(
    Object.entries(items).map(async ([k, x]) => {
      const pathNestings = x.relativePath.split("/");
      pathNestings.pop();
      if (pathNestings.length > 0) {
        await ensureDir(join(tempOpen, ...pathNestings));
      }
      const path = join(tempOpen, x.relativePath);
      if (x.content) {
        await writeFile(path, x.content);
      }
      x.path = path;
      return [k, x];
    })
  );
  return files.reduce(
    (acc, [role, x]) => ({
      ...acc,
      [role]: x,
    }),
    {}
  ) as TestFileItems;
}
