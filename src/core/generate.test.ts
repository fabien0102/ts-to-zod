import { generate } from "./generate";
import temp from "temp";
import { writeFile, ensureDir } from "fs-extra";
import { join } from "path";

describe("generate", () => {
  let getZodSchemasFile: (s: string) => string | undefined;
  let getIntegrationTestFile: (s: string, t: string) => string | undefined;
  let errors: Array<string> = [];
  let tempOpen: string;
  let outputFile = "";
  let inputPath = "";

  beforeAll(async () => {
    temp.track();
    tempOpen = await temp.mkdir("ts-to-zod");
  });

  describe("simple case", () => {
    const sourceText = `
      export type Name = "superman" | "clark kent" | "kal-l";

      // Note that the Superman is declared after
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      export interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }

      const fly = () => console.log("I can fly!");
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "hero");
      inputPath = join(tempOpen, "hero.ts");
      await writeFile(inputPath, sourceText);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const nameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const supermanSchema = z.object({
            name: nameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });

        export const badassSupermanSchema = supermanSchema.omit({ \\"underKryptonite\\": true });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(getIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type nameSchemaInferredType = z.infer<typeof generated.nameSchema>;

        export type supermanSchemaInferredType = z.infer<typeof generated.supermanSchema>;

        export type badassSupermanSchemaInferredType = z.infer<typeof generated.badassSupermanSchema>;
        expectType<spec.Name>({} as nameSchemaInferredType)
        expectType<nameSchemaInferredType>({} as spec.Name)
        expectType<spec.Superman>({} as supermanSchemaInferredType)
        expectType<supermanSchemaInferredType>({} as spec.Superman)
        expectType<spec.BadassSuperman>({} as badassSupermanSchemaInferredType)
        expectType<badassSupermanSchemaInferredType>({} as spec.BadassSuperman)
        "
      `);
    });
    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("with enums", () => {
    const sourceText = `
      export enum Superhero {
        Superman = "superman",
        ClarkKent = "clark-kent"
      };

      export type FavoriteSuperhero = {
        superhero: Superhero.Superman
      };
      `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "superhero");
      inputPath = join(tempOpen, "superhero.ts");
      await writeFile(inputPath, sourceText);
      const res = await generate({
        inputPath,
      });
      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Superhero } from \\"./superhero\\";

        export const superheroSchema = z.nativeEnum(Superhero);

        export const favoriteSuperheroSchema = z.object({
            superhero: z.literal(Superhero.Superman)
        });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(getIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type superheroSchemaInferredType = z.infer<typeof generated.superheroSchema>;

        export type favoriteSuperheroSchemaInferredType = z.infer<typeof generated.favoriteSuperheroSchema>;
        expectType<spec.Superhero>({} as superheroSchemaInferredType)
        expectType<superheroSchemaInferredType>({} as spec.Superhero)
        expectType<spec.FavoriteSuperhero>({} as favoriteSuperheroSchemaInferredType)
        expectType<favoriteSuperheroSchemaInferredType>({} as spec.FavoriteSuperhero)
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("with circular references", () => {
    const sourceText = `
      export interface Villain {
        name: string;
        powers: string[];
        friends: Villain[];
      }

      export interface EvilPlan {
        owner: Villain;
        description: string;
        details: EvilPlanDetails;
      }

      export interface EvilPlanDetails {
        parent: EvilPlan; // <- Unsolvable circular reference
        steps: string[];
      }
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "villain");
      inputPath = join(tempOpen, "villain.ts");
      await writeFile(inputPath, sourceText);
      const res = await generate({
        inputPath,
        maxRun: 3,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Villain } from \\"./villain\\";

        export const villainSchema: z.ZodSchema<Villain> = z.lazy(() => z.object({
            name: z.string(),
            powers: z.array(z.string()),
            friends: z.array(villainSchema)
        }));
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(getIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type villainSchemaInferredType = z.infer<typeof generated.villainSchema>;
        expectType<spec.Villain>({} as villainSchemaInferredType)
        expectType<villainSchemaInferredType>({} as spec.Villain)
        "
      `);
    });

    it("should have some errors", () => {
      expect(errors).toMatchInlineSnapshot(`
        Array [
          "Some schemas can't be generated due to circular dependencies:
        evilPlanSchema
        evilPlanDetailsSchema",
        ]
      `);
    });
  });

  describe("with options", () => {
    const sourceText = `export interface Superman {
      /**
       * Name of superman
       */
      name: string;
    }

    export interface Villain {
      name: string;
      didKillSuperman: true;
    }
    `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "villain");
      inputPath = join(tempOpen, "villain.ts");
      await writeFile(inputPath, sourceText);

      const res = await generate({
        inputPath,
        nameFilter: (id) => id === "Superman",
        getSchemaName: (id) => id.toLowerCase(),
        keepComments: true,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate superman schema", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const superman = z.object({
            /**
             * Name of superman
             */
            name: z.string()
        });
        "
      `);
    });
  });

  describe("inheritance and reference type search", () => {
    const sourceText = `
    export type Name = "superman" | "clark kent" | "kal-l";
    export interface Superman {
      name: Name;
    }`;

    beforeAll(async () => {
      outputFile = join(tempOpen, "superman");
      inputPath = join(tempOpen, "superman.ts");
      await writeFile(inputPath, sourceText);
      const res = await generate({
        inputPath,
        nameFilter: (id) => id === "Superman",
        getSchemaName: (id) => id.toLowerCase(),
        keepComments: true,
      });
      getZodSchemasFile = res.getZodSchemasFile;
    });

    it("should generate superman schema", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const name = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const superman = z.object({
            name: name
        });
        "
      `);
    });
  });

  describe("with jsdocTags filter", () => {
    const sourceText = `
      /**
       * @zod
       **/
      export type Name = "superman" | "clark kent" | "kal-l";

      /**
       * @nop
       */
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      /**
       * Only this interface should be generated
       *
       * @zod
       */
      export interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }
      `;
    it("should generate only types with @zod", async () => {
      outputFile = join(tempOpen, "source");
      inputPath = join(tempOpen, "source.ts");
      await writeFile(inputPath, sourceText);
      const { getZodSchemasFile: localGetZodSchemaFile } = await generate({
        inputPath,
        jsDocTagFilter: (tags) => tags.map((tag) => tag.name).includes("zod"),
      });

      expect(localGetZodSchemaFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const nameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const supermanSchema = z.object({
            name: nameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });
        "
      `);
    });
  });

  describe("with non-exported types", () => {
    const sourceText = `
      export type Name = "superman" | "clark kent" | "kal-l";

      // Note that the Superman is declared after
      export type BadassSuperman = Omit<Superman, "underKryptonite">;

      interface Superman {
        name: Name;
        age: number;
        underKryptonite?: boolean;
        /**
         * @format email
         **/
        email: string;
      }
      `;
    it("should generate tests for exported schemas", async () => {
      outputFile = join(tempOpen, "source.zod.ts");
      inputPath = join(tempOpen, "source.ts");
      await writeFile(inputPath, sourceText);
      const {
        getIntegrationTestFile: localGetIntegrationTestFile,
      } = await generate({
        inputPath,
      });

      expect(localGetIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type nameSchemaInferredType = z.infer<typeof generated.nameSchema>;

        export type badassSupermanSchemaInferredType = z.infer<typeof generated.badassSupermanSchema>;
        expectType<spec.Name>({} as nameSchemaInferredType)
        expectType<nameSchemaInferredType>({} as spec.Name)
        expectType<spec.BadassSuperman>({} as badassSupermanSchemaInferredType)
        expectType<badassSupermanSchemaInferredType>({} as spec.BadassSuperman)
        "
      `);
    });
  });

  describe("with namespace", () => {
    const sourceText = `
      export namespace Metropolis {
        export type Name = "superman" | "clark kent" | "kal-l";

        // Note that the Superman is declared after
        export type BadassSuperman = Omit<Superman, "underKryptonite">;

        export interface Superman {
          name: Name;
          age: number;
          underKryptonite?: boolean;
          /**
           * @format email
           **/
          email: string;
        }

        const fly = () => console.log("I can fly!");
      }
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "hero");
      inputPath = join(tempOpen, "hero.ts");
      await writeFile(inputPath, sourceText);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const metropolisNameSchema = z.union([z.literal(\\"superman\\"), z.literal(\\"clark kent\\"), z.literal(\\"kal-l\\")]);

        export const metropolisSupermanSchema = z.object({
            name: metropolisNameSchema,
            age: z.number(),
            underKryptonite: z.boolean().optional(),
            email: z.string().email()
        });

        export const metropolisBadassSupermanSchema = metropolisSupermanSchema.omit({ \\"underKryptonite\\": true });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(getIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type metropolisNameSchemaInferredType = z.infer<typeof generated.metropolisNameSchema>;

        export type metropolisSupermanSchemaInferredType = z.infer<typeof generated.metropolisSupermanSchema>;

        export type metropolisBadassSupermanSchemaInferredType = z.infer<typeof generated.metropolisBadassSupermanSchema>;
        expectType<spec.MetropolisName>({} as metropolisNameSchemaInferredType)
        expectType<metropolisNameSchemaInferredType>({} as spec.MetropolisName)
        expectType<spec.MetropolisSuperman>({} as metropolisSupermanSchemaInferredType)
        expectType<metropolisSupermanSchemaInferredType>({} as spec.MetropolisSuperman)
        expectType<spec.MetropolisBadassSuperman>({} as metropolisBadassSupermanSchemaInferredType)
        expectType<metropolisBadassSupermanSchemaInferredType>({} as spec.MetropolisBadassSuperman)
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors).toEqual([]);
    });
  });

  describe("importing named export types from another file", () => {
    const sourceText = `
        import { HeadQuarters } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
        }
      `;
    let utilsPath: string;
    const sourceTextUtils = `
        export type HeadQuarters = {
          name: string;
          location: string;
        };
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "hero");
      inputPath = join(tempOpen, "hero.ts");
      utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const headQuartersSchema = z.object({
            name: z.string(),
            location: z.string()
        });

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: headQuartersSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors).toEqual([]);
    });
  });

  describe("importing aggregated named export types from another file", () => {
    const sourceText = `
        import { HeadQuarters } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
        }
      `;
    const sourceTextUtils = `
        type HeadQuarters = {
          name: string;
          location: string;
        };
        export { HeadQuarters };
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "hero");
      inputPath = join(tempOpen, "hero.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const headQuartersSchema = z.object({
            name: z.string(),
            location: z.string()
        });

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: headQuartersSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors).toEqual([]);
    });
  });

  describe("importing named aliased export types from another file", () => {
    const sourceText = `
        import { HeadQuarters as HQs, Color} from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HQs;
          favoriteColor: Color;
        }
      `;
    let utilsPath: string;
    const sourceTextUtils = `
        export type HeadQuarters = {
          name: string;
          location: string;
        };
        export type Color = 'black' | 'white';
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "hero");
      inputPath = join(tempOpen, "hero.ts");
      utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const hQsSchema = z.object({
            name: z.string(),
            location: z.string()
        });
        
        export const colorSchema = z.union([z.literal(\\"black\\"), z.literal(\\"white\\")]);

        export const enemySchema = z.object({
            name: z.string(),
            inPrison: z.boolean(),
            headQuarters: hQsSchema,
            favoriteColor: colorSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors).toEqual([]);
    });
  });

  describe("importing mixed export types from another file", () => {
    const sourceText = `
        import HeadQuarters, { Vehicle, Color } from "./utils";
        
        export interface Enemy {
          name: string;
          inPrison: boolean;
          headQuarters: HeadQuarters ;
          vehicle: Vehicle;
        }
      `;
    const sourceTextUtils = `
        type HeadQuarters = {
          name: string;
          location: string;
        };
        type Color = string;
        export type VehicleKind = 'car' | 'plane' | 'boat';
        export type Vehicle = {
          kind: VehicleKind
          color: string
          mileage: number;
        }
        
        export { Color };
        export default HeadQuarters;
      `;
    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
      "// Generated by ts-to-zod
      import { z } from \\"zod\\";
      
      export const headQuartersSchema = z.object({
          name: z.string(),
          location: z.string()
      });
      
      export const colorSchema = z.string();
      
      export const vehicleKindSchema = z.union([z.literal(\\"car\\"), z.literal(\\"plane\\"), z.literal(\\"boat\\")]);
      
      export const vehicleSchema = z.object({
          kind: vehicleKindSchema,
          color: z.string(),
          mileage: z.number()
      });
      
      export const enemySchema = z.object({
          name: z.string(),
          inPrison: z.boolean(),
          headQuarters: headQuartersSchema,
          vehicle: vehicleSchema
      });
      "
      `);
    });

    it("should not have any errors", () => {
      expect(errors).toEqual([]);
    });
  });

  afterAll(async () => {
    await temp.cleanup();
  });

  describe("Parse typeLiteral properties as we do with interface properties", () => {
    const sourceText = `
        import { Sport } from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: Sport;
         }; 
    `;
    const sourceTextUtils = `
        type Sport = "football" | "basketball" | "baseball";
        export { Sport };
    `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const sportSchema = z.union([z.literal(\\"football\\"), z.literal(\\"basketball\\"), z.literal(\\"baseball\\")]);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: sportSchema
        });
        "
      `);
    });

    it("should generate the integration tests", () => {
      expect(getIntegrationTestFile(inputPath, outputFile))
        .toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        import * as spec from \\"${inputPath}\\";
        import * as generated from \\"${outputFile}\\";

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        function expectType<T>(_: T) {
          /* noop */
        }

        export type sportSchemaInferredType = z.infer<typeof generated.sportSchema>;
        expectType<spec.Sport>({} as sportSchemaInferredType)
        expectType<sportSchemaInferredType>({} as spec.Sport)
        "
        `);
    });
    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("Importing default export type", () => {
    const sourceText = `
        import FavoriteSport from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
         }; 
    `;
    const sourceTextUtils = `
        type Sport = "football" | "basketball" | "baseball";
        export default Sport;
    `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";

        export const favoriteSportSchema = z.union([z.literal(\\"football\\"), z.literal(\\"basketball\\"), z.literal(\\"baseball\\")]);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("Importing default export enum", () => {
    const sourceText = `
        import FavoriteSport from "./utils";
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
         }; 
    `;
    const sourceTextUtils = `
        enum Sport  {
          Football,
          Basketball,
        }
        export type Color = "red" | "blue";
        export default Sport;
    `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import FavoriteSport from \\"./utils\\";
        
        export const favoriteSportSchema = z.nativeEnum(FavoriteSport);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });

  describe("Deep nesting imported types", () => {
    const sourceText = `
        import FavoriteSport from "./utils";
        import { Nationality } from "./utils/extra
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
             nationality: Nationality;
         }; 
    `;
    const sourceTextUtils = `
        import { Color } from "./color";
        export { Color }
        enum Sport  {
          Football,
          Basketball,
        }
        export default Sport;
    `;
    const sourceTextUtilsColor = `
        export type Color = "red" | "blue";
    `;
    const sourceTextUtilsExtra = `
      export enum Nationality {
        American,
        Canadian,
        Italian,
      }
    `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await ensureDir(join(tempOpen, "utils"));
      const utilsExtraPath = join(tempOpen, "utils/extra.ts");
      await ensureDir(join(tempOpen, "colors"));
      const utilsColorPath = join(tempOpen, "colors/index.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
        writeFile(utilsColorPath, sourceTextUtilsColor),
        writeFile(utilsExtraPath, sourceTextUtilsExtra),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import FavoriteSport from \\"./utils\\";
        import { Nationality } from \\"./utils/extra\\";
        
        export const favoriteSportSchema = z.nativeEnum(FavoriteSport);

        export const nationalitySchema = z.nativeEnum(Nationality);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema,
            nationality: nationalitySchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });
  describe("Cross Referencing imported types", () => {
    const sourceText = `
        import FavoriteSport from "./utils";
        import { Nationality } from "./utils/extra
        type Enemy = {
             name: string;
             favoriteSport: FavoriteSport;
             nationality: Nationality;
         }; 
    `;
    const sourceTextUtils = `
        import { Color } from "./colors";
        import { Nationality as Nations } from "./utils/extra";
        export { Color }
        enum SportTypes  {
          Football,
          Basketball,
        }
        type Sport = {
           nation: Nations
           color: Color
        }
        export default Sport;
    `;
    const sourceTextUtilsColor = `
        export type Color = "red" | "blue";
    `;
    const sourceTextUtilsExtra = `
      export enum Nationality {
        American,
        Canadian,
        Italian,
      }
    `;

    beforeAll(async () => {
      outputFile = join(tempOpen, "main");
      inputPath = join(tempOpen, "main.ts");
      const utilsPath = join(tempOpen, "utils.ts");
      await ensureDir(join(tempOpen, "utils"));
      const utilsExtraPath = join(tempOpen, "utils/extra.ts");
      await ensureDir(join(tempOpen, "colors"));
      const utilsColorPath = join(tempOpen, "colors/index.ts");
      await Promise.all([
        writeFile(inputPath, sourceText),
        writeFile(utilsPath, sourceTextUtils),
        writeFile(utilsColorPath, sourceTextUtilsColor),
        writeFile(utilsExtraPath, sourceTextUtilsExtra),
      ]);
      const res = await generate({
        inputPath,
      });

      getZodSchemasFile = res.getZodSchemasFile;
      getIntegrationTestFile = res.getIntegrationTestFile;
      errors = res.errors;
    });

    it("should generate the zod schemas", () => {
      expect(getZodSchemasFile(outputFile)).toMatchInlineSnapshot(`
        "// Generated by ts-to-zod
        import { z } from \\"zod\\";
        import { Nationality } from \\"./utils/extra\\";
        
        export const colorSchema = z.union([z.literal(\\"red\\"), z.literal(\\"blue\\")]);

        export const nationsSchema = z.nativeEnum(Nationality);

        export const favoriteSportSchema = z.object({
            nation: nationsSchema,
            color: colorSchema
        });
        
        export const nationalitySchema = z.nativeEnum(Nationality);
        
        const enemySchema = z.object({
            name: z.string(),
            favoriteSport: favoriteSportSchema,
            nationality: nationalitySchema
        });
        "
      `);
    });

    it("should not have any errors", () => {
      expect(errors.length).toBe(0);
    });
  });
});
